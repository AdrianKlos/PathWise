

    // --- Global Variables and Constants ---
    const API_KEY = "AIzaSyDLnGHw5jc227pi3LBqjtr74k3ybwwcWCM"; // Canvas will provide this API key at runtime.
    const BASE_URL = "https://maps.googleapis.com/maps/api/geocode/json";
    const R = 6371; // Earth radius in km

    let currentLocation = null; // [longitude, latitude] array
    let isAuthReady = false; // Flag for geocoding
    let enterAddress = prompt("Where would you like to go?");
    let currentCoordsDisplay;
    let myData;

    // import myData from './filtered.geojson' with { type: 'json' };
    
async function init() {
    try {
        const response = await fetch('./filtered.geojson');

        if (!response.ok) {
            throw new Error(`HTTP error! Status: ${response.status}`);
        }

        // myData is assigned the entire GeoJSON object
        myData = await response.json(); 
        
        // Ensure myData is a FeatureCollection and has the 'features' array
        if (myData.type !== "FeatureCollection" || !Array.isArray(myData.features)) {
            console.error("GeoJSON data is not a valid FeatureCollection.");
            return;
        }
            console.log(`Starting graph creation for ${myData.features.length} features...`);
            
            // Start the routing code here
            for (const feature of myData.features) {
            const geom = feature.geometry;

            if (geom.type === "Point") {
                // [lon, lat] format
                const coord = geom.coordinates;
                getCoordIndex(coord); // Add point to coords array
            } else if (geom.type === "LineString") {
                const indices = [];
                for (const coord of geom.coordinates) {
                    indices.push(getCoordIndex(coord));
                }
                // Connect consecutive nodes in the LineString
                for (let i = 0; i < indices.length - 1; i++) {
                    addEdge(indices[i], indices[i + 1]);
                }
            }
        }
        
        console.log("Graph creation complete!");
        console.log("Graph Nodes:", coords);
        console.log("Graph Edges:", graph);

        // --- END ---

    }catch (error) {
        console.error('Failed to fetch data:', error);
    }
}


    /**
     * Haversine function (distance between two coords)
     * @param {number[]} coord1 - [lon1, lat1]
     * @param {number[]} coord2 - [lon2, lat2]
     * @returns {number} Distance in kilometers.
     */
    function haversine(coord1, coord2) {
      const [lon1, lat1] = coord1;
      const [lon2, lat2] = coord2;

      const toRad = (degree) => (degree * Math.PI) / 180;

      const dlon = toRad(lon2 - lon1);
      const dlat = toRad(lat2 - lat1);

      const a = Math.sin(dlat / 2) ** 2 +
        Math.cos(toRad(lat1)) *
        Math.cos(toRad(lat2)) *
        Math.sin(dlon / 2) ** 2;

      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      return R * c; // Distance in km
    }

    /**
     * Uses the HTML Geolocation API to get the user's current coordinates.
     */
    function getCurrentLocation() {
      if (navigator.geolocation) {
        navigator.geolocation.getCurrentPosition(
          (position) => {
            // Coordinates in [lon, lat] format (standard GeoJSON/API order)
            currentLocation = [
              position.coords.longitude,
              position.coords.latitude
            ];
            const lat = position.coords.latitude.toFixed(6);
            const lon = position.coords.longitude.toFixed(6);
            currentCoordsDisplay = `${lat}, ${lon}`;
            console.log(currentCoordsDisplay)
            isAuthReady = true;
            console.log("Current Location:", currentLocation);
          },
          (error) => {
            console.error("Geolocation error:", error);
            // Fallback to a hardcoded test location if permission is denied
            currentLocation = [-88.0531299984337, 42.0629624921386];
            currentCoordsDisplay = `[-88.0531, 42.0629] (Using fallback test coordinates)`;
            console.log(currentCoordsDisplay)
            isAuthReady = true;
            showError(`Could not get your live location (${error.message}). Using fallback coordinates for testing.`);
          }
        );
      } else {
        currentCoordsDisplay.textContent = 'Geolocation is not supported by this browser. Using fallback test coordinates.';
        currentLocation = [-88.0531299984337, 42.0629624921386];
        isAuthReady = true;
      }
    }

    // --- Main Logic Function ---

//     async function geocodeAndRoute() {

//       if (!currentLocation) {
//         return console.log("Current location is not yet determined. Please wait or refresh.");
//       }

//       const address = enterAddress;
//       if (!address) {
//         return console.log("Please enter a destination address.");
//       }

//       const geocodingUrl = new URL(BASE_URL);
//       geocodingUrl.searchParams.append('address', address);
//       geocodingUrl.searchParams.append('key', API_KEY);

//       let destinationCoords = null;
//       let formattedAddress = '';

//       // 1. Geocoding API Call
//       try {
//         const response = await fetch(geocodingUrl.toString());
//         if (!response.ok) {
//           throw new Error(`HTTP error! status: ${response.status}`);
//         }
//         const data = await response.json();

//         if (data.status === 'OK') {
//           const result = data.results[0];
//           const lat = result.geometry.location.lat;
//           const lon = result.geometry.location.lng;
//           formattedAddress = result.formatted_address;
//           // API returns [lon, lat]
//           destinationCoords = [lon, lat];

//           const output = `
// Address: ${formattedAddress}
// Latitude: ${lat.toFixed(6)}
// Longitude: ${lon.toFixed(6)}
//                     `;
//           console.log(output)

//         } else {
//           throw new Error(`Geocoding failed. Status: ${data.status}. ${data.error_message || ''}`);
//         }
//       } catch (e) {
//         return showError(`Geocoding Error: ${e.message}`);
//       }

//       // 2. Graph Construction and Closest Node Finding
//       const graph = {};
//       const coords = []; // Stores all unique [lon, lat] tuples/arrays
//       let closestNodeIndex = null;
//       let minDistanceToDestination = Infinity;

//       // Helper to get index or add new coordinate
//       function getCoordIndex(coord) {
//         // Check if coordinate already exists in the list
//         const existingIndex = coords.findIndex(c => c[0] === coord[0] && c[1] === coord[1]);
//         if (existingIndex !== -1) {
//           return existingIndex;
//         }
//         // Add new coordinate
//         coords.push(coord);
//         return coords.length - 1;
//       }

//       // Helper to add edges to the graph
//       function addEdge(i, j) {
//         const d = haversine(coords[i], coords[j]);

//         // Initialize the node entries if they don't exist
//         if (!graph[i]) graph[i] = {};
//         if (!graph[j]) graph[j] = {};

//         // Update edge weights (distance)
//         graph[i][j] = d;
//         graph[j][i] = d;
//       }

//       // Gets the Geojson data here:
//       for (const feature of myData.features) {
//         const geom = feature.geometry;

//         if (geom.type === "Point") {
//           // [lon, lat] format
//           const coord = geom.coordinates;
//           getCoordIndex(coord); // Add point to coords array
//         } else if (geom.type === "LineString") {
//           const indices = [];
//           for (const coord of geom.coordinates) {
//             indices.push(getCoordIndex(coord));
//           }
//           // Connect consecutive nodes in the LineString
//           for (let i = 0; i < indices.length - 1; i++) {
//             addEdge(indices[i], indices[i + 1]);
//           }
//         }
//       }
//       console.log("Graph Nodes:", coords);
//       console.log("Graph Edges:", graph);


//       // 3. Find the closest node in our network (coords) to the destination
//       coords.forEach((nodeCoord, index) => {
//         const distance = haversine(destinationCoords, nodeCoord);
//         if (distance < minDistanceToDestination) {
//           minDistanceToDestination = distance;  
//           closestNodeIndex = index;
//         }
//       });

//       // 4. Display Routing Results
//       let routingOutput = "";

//       if (closestNodeIndex !== null) {
//         const closestNodeCoord = coords[closestNodeIndex];
//         const [lon, lat] = closestNodeCoord;

//         routingOutput = `
// Destination: ${formattedAddress}
// Destination Coords: [${destinationCoords[1].toFixed(6)}, ${destinationCoords[0].toFixed(6)}]
// --- Closest Network Node Found ---
// Node Coords: [${lat.toFixed(6)}, ${lon.toFixed(6)}]
// Distance to Destination: ${minDistanceToDestination.toFixed(3)} km
// This node is the starting point for route calculation (Dijkstra's).
// Current Location (Start): [${currentLocation[1].toFixed(6)}, ${currentLocation[0].toFixed(6)}]
//                 `;
//       } else {
//         routingOutput = "Error: No nodes were found in the GeoJSON network to route from.";
//       }

//       console.log(routingOutput)
//       geocodeAndRoute()
//       // 5. Finalize
//     }

    // --- Initialization ---
    // document.addEventListener('DOMContentLoaded', () => {
    //   getCurrentLocation();
    // });


    async function initMap() {
    const { Map } = await google.maps.importLibrary("maps");
    const map = new Map(document.getElementById("map"), {
        center: { lat: 37.42, lng: -122.1 },
        zoom: 14,
        mapId: "4504f8b37365c3d0",
    });
}

    window.initMap = initMap; // required for callback
